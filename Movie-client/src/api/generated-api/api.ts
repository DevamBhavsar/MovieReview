/* tslint:disable */
/* eslint-disable */
/**
 * MovieReview API Specification
 * OpenApi documentation for MovieReview API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: contact@moviereview.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface GrantedAuthority
 */
export interface GrantedAuthority {
  /**
   *
   * @type {string}
   * @memberof GrantedAuthority
   */
  authority?: string;
}
/**
 *
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  password: string;
}
/**
 *
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  token?: string;
}
/**
 *
 * @export
 * @interface MovieWithReviewsDTO
 */
export interface MovieWithReviewsDTO {
  /**
   *
   * @type {string}
   * @memberof MovieWithReviewsDTO
   */
  imdbId?: string;
  /**
   *
   * @type {string}
   * @memberof MovieWithReviewsDTO
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof MovieWithReviewsDTO
   */
  releaseDate?: string;
  /**
   *
   * @type {string}
   * @memberof MovieWithReviewsDTO
   */
  trailerLink?: string;
  /**
   *
   * @type {string}
   * @memberof MovieWithReviewsDTO
   */
  poster?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof MovieWithReviewsDTO
   */
  genres?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof MovieWithReviewsDTO
   */
  backdrops?: Array<string>;
  /**
   *
   * @type {Array<ReviewDTO>}
   * @memberof MovieWithReviewsDTO
   */
  reviews?: Array<ReviewDTO>;
}
/**
 *
 * @export
 * @interface Movies
 */
export interface Movies {
  /**
   *
   * @type {ObjectId}
   * @memberof Movies
   */
  id?: ObjectId;
  /**
   *
   * @type {string}
   * @memberof Movies
   */
  imdbId: string;
  /**
   *
   * @type {string}
   * @memberof Movies
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof Movies
   */
  releaseDate?: string;
  /**
   *
   * @type {string}
   * @memberof Movies
   */
  trailerLink?: string;
  /**
   *
   * @type {string}
   * @memberof Movies
   */
  poster?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Movies
   */
  genres?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Movies
   */
  backdrops?: Array<string>;
  /**
   *
   * @type {Array<Reviews>}
   * @memberof Movies
   */
  reviewIds?: Array<Reviews>;
}
/**
 *
 * @export
 * @interface ObjectId
 */
export interface ObjectId {
  /**
   *
   * @type {number}
   * @memberof ObjectId
   */
  timestamp?: number;
  /**
   *
   * @type {string}
   * @memberof ObjectId
   */
  date?: string;
}
/**
 *
 * @export
 * @interface ReviewDTO
 */
export interface ReviewDTO {
  /**
   *
   * @type {string}
   * @memberof ReviewDTO
   */
  body?: string;
  /**
   *
   * @type {string}
   * @memberof ReviewDTO
   */
  username?: string;
}
/**
 *
 * @export
 * @interface Reviews
 */
export interface Reviews {
  /**
   *
   * @type {string}
   * @memberof Reviews
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Reviews
   */
  createdDate?: string;
  /**
   *
   * @type {string}
   * @memberof Reviews
   */
  lastModifiedDate?: string;
  /**
   *
   * @type {string}
   * @memberof Reviews
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Reviews
   */
  lastModifiedBy?: string;
  /**
   *
   * @type {string}
   * @memberof Reviews
   */
  body: string;
  /**
   *
   * @type {Movies}
   * @memberof Reviews
   */
  movie?: Movies;
  /**
   *
   * @type {User}
   * @memberof Reviews
   */
  user?: User;
}
/**
 *
 * @export
 * @interface Role
 */
export interface Role {
  /**
   *
   * @type {string}
   * @memberof Role
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Role
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Role
   */
  createdDate: string;
  /**
   *
   * @type {string}
   * @memberof Role
   */
  lastUpdatedDate: string;
}
/**
 *
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  password: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  accountLocked?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  createdDate: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastUpdatedDate: string;
  /**
   *
   * @type {Set<Role>}
   * @memberof User
   */
  roles?: Set<Role>;
  /**
   *
   * @type {Array<GrantedAuthority>}
   * @memberof User
   */
  authorities?: Array<GrantedAuthority>;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  accountNonExpired?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  accountNonLocked?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  credentialsNonExpired?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  name?: string;
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm: async (
      token: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists("confirm", "token", token);
      const localVarPath = `/auth/activate-account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      loginRequest: LoginRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginRequest' is not null or undefined
      assertParamExists("login", "loginRequest", loginRequest);
      const localVarPath = `/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SignupRequest} signupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser: async (
      signupRequest: SignupRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signupRequest' is not null or undefined
      assertParamExists("registerUser", "signupRequest", signupRequest);
      const localVarPath = `/auth/signup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signupRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AuthControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirm(
      token: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirm(
        token,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthControllerApi.confirm"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      loginRequest: LoginRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        loginRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthControllerApi.login"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {SignupRequest} signupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerUser(
      signupRequest: SignupRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(
        signupRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthControllerApi.registerUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthControllerApiFp(configuration);
  return {
    /**
     *
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm(
      token: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .confirm(token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      loginRequest: LoginRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<LoginResponse> {
      return localVarFp
        .login(loginRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SignupRequest} signupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(
      signupRequest: SignupRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .registerUser(signupRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
  /**
   *
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public confirm(token: string, options?: RawAxiosRequestConfig) {
    return AuthControllerApiFp(this.configuration)
      .confirm(token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {LoginRequest} loginRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
    return AuthControllerApiFp(this.configuration)
      .login(loginRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SignupRequest} signupRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public registerUser(
    signupRequest: SignupRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthControllerApiFp(this.configuration)
      .registerUser(signupRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MovieControllerApi - axios parameter creator
 * @export
 */
export const MovieControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllMovies: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/movies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} imdbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMovieByImdbId: async (
      imdbId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'imdbId' is not null or undefined
      assertParamExists("getMovieByImdbId", "imdbId", imdbId);
      const localVarPath = `/movies/{imdbId}`.replace(
        `{${"imdbId"}}`,
        encodeURIComponent(String(imdbId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} imdbId
     * @param {Movies} movies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMovie: async (
      imdbId: string,
      movies: Movies,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'imdbId' is not null or undefined
      assertParamExists("updateMovie", "imdbId", imdbId);
      // verify required parameter 'movies' is not null or undefined
      assertParamExists("updateMovie", "movies", movies);
      const localVarPath = `/movies/{imdbId}`.replace(
        `{${"imdbId"}}`,
        encodeURIComponent(String(imdbId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        movies,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MovieControllerApi - functional programming interface
 * @export
 */
export const MovieControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MovieControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllMovies(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Movies>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMovies(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MovieControllerApi.getAllMovies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} imdbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMovieByImdbId(
      imdbId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MovieWithReviewsDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMovieByImdbId(imdbId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MovieControllerApi.getMovieByImdbId"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} imdbId
     * @param {Movies} movies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMovie(
      imdbId: string,
      movies: Movies,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Movies>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateMovie(
        imdbId,
        movies,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MovieControllerApi.updateMovie"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MovieControllerApi - factory interface
 * @export
 */
export const MovieControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MovieControllerApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllMovies(options?: RawAxiosRequestConfig): AxiosPromise<Array<Movies>> {
      return localVarFp
        .getAllMovies(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} imdbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMovieByImdbId(
      imdbId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MovieWithReviewsDTO> {
      return localVarFp
        .getMovieByImdbId(imdbId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} imdbId
     * @param {Movies} movies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMovie(
      imdbId: string,
      movies: Movies,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Movies> {
      return localVarFp
        .updateMovie(imdbId, movies, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MovieControllerApi - object-oriented interface
 * @export
 * @class MovieControllerApi
 * @extends {BaseAPI}
 */
export class MovieControllerApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public getAllMovies(options?: RawAxiosRequestConfig) {
    return MovieControllerApiFp(this.configuration)
      .getAllMovies(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} imdbId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public getMovieByImdbId(imdbId: string, options?: RawAxiosRequestConfig) {
    return MovieControllerApiFp(this.configuration)
      .getMovieByImdbId(imdbId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} imdbId
   * @param {Movies} movies
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public updateMovie(
    imdbId: string,
    movies: Movies,
    options?: RawAxiosRequestConfig
  ) {
    return MovieControllerApiFp(this.configuration)
      .updateMovie(imdbId, movies, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MoviesApplicationApi - axios parameter creator
 * @export
 */
export const MoviesApplicationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    helloWorld: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/hello`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MoviesApplicationApi - functional programming interface
 * @export
 */
export const MoviesApplicationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MoviesApplicationApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async helloWorld(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.helloWorld(
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoviesApplicationApi.helloWorld"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MoviesApplicationApi - factory interface
 * @export
 */
export const MoviesApplicationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MoviesApplicationApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    helloWorld(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .helloWorld(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MoviesApplicationApi - object-oriented interface
 * @export
 * @class MoviesApplicationApi
 * @extends {BaseAPI}
 */
export class MoviesApplicationApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoviesApplicationApi
   */
  public helloWorld(options?: RawAxiosRequestConfig) {
    return MoviesApplicationApiFp(this.configuration)
      .helloWorld(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ReviewControllerApi - axios parameter creator
 * @export
 */
export const ReviewControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {Reviews} reviews
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReview: async (
      reviews: Reviews,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviews' is not null or undefined
      assertParamExists("createReview", "reviews", reviews);
      const localVarPath = `/reviews`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        reviews,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ReviewControllerApi - functional programming interface
 * @export
 */
export const ReviewControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ReviewControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {Reviews} reviews
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createReview(
      reviews: Reviews,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reviews>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createReview(
        reviews,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ReviewControllerApi.createReview"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ReviewControllerApi - factory interface
 * @export
 */
export const ReviewControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ReviewControllerApiFp(configuration);
  return {
    /**
     *
     * @param {Reviews} reviews
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReview(
      reviews: Reviews,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Reviews> {
      return localVarFp
        .createReview(reviews, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ReviewControllerApi - object-oriented interface
 * @export
 * @class ReviewControllerApi
 * @extends {BaseAPI}
 */
export class ReviewControllerApi extends BaseAPI {
  /**
   *
   * @param {Reviews} reviews
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewControllerApi
   */
  public createReview(reviews: Reviews, options?: RawAxiosRequestConfig) {
    return ReviewControllerApiFp(this.configuration)
      .createReview(reviews, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
